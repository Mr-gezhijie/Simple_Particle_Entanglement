<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Element</title>
    <style>
        .draggableElement {
            width: 100px;
            height: 100px;
            background-color: lightblue;
            position: fixed;
            cursor: grab;
        }

        .line {
            position: fixed;
            background-color: black;
            height: 2px;
            width: 0;
        }
    </style>
</head>

<body>
    <!-- <div id="draggableElement">Drag me!</div> -->
    <!-- <div class="line" id="line"></div> -->

    <script>

        ////////////////////////////////////////////////////////////////定时刷新////////////////////////////////////////////////////////////////
        let time
        function timeX() {
            time = setInterval(criminalProcedure, 100)
        }
        timeX()


        ////////////////////////////////////////////////////////拖动效果////////////////////////////////////////////////////////////////
        //拖动效果初始化
        setTimeout(dragEffect, 500)
        function dragEffect() {
            const draggableElements = document.querySelectorAll('.draggableElement');
            let localStorageKeys = Object.keys(localStorage);
            for (let i = 0; i < draggableElements.length; i++) {
                const draggableElement = draggableElements[i];
                let x, y
                let offsetX, offsetY;
                let isDragging = false;


                //实现每次加载，覆盖的效果
                draggableElement.onmousedown = function (e) {
                    isDragging = true;
                    offsetX = e.clientX - draggableElement.getBoundingClientRect().left;
                    offsetY = e.clientY - draggableElement.getBoundingClientRect().top;
                    console.log('手的位置', offsetX, offsetY);
                    draggableElement.style.cursor = 'grabbing';
                    // clearInterval(time)
                };

                draggableElement.onmousemove = function (e) {
                    console.log('yidong');
                    if (!isDragging) return;
                    const x = e.clientX - offsetX;
                    const y = e.clientY - offsetY;
                    console.log(x, y);
                    draggableElement.style.left = x + 'px';
                    draggableElement.style.top = y + 'px';
                    //修改位置
                    modifyCoordinates(draggableElement)
                };

                draggableElement.onmouseup = function (e) {
                    console.log('释放');
                    isDragging = false;
                    draggableElement.style.cursor = 'grab';
                    updateCoordinates()
                    // timeX()

                };



            }

        }



        ////////////////////////////////////////////////////////////// 页面数据存储////////////////////////////////////////////////////////////
        // 生成一个唯一的标识符
        function generateUniqueId() {
            return 'id-' + Math.random().toString(36).substr(2, 16);
        }

        // 获取当前标签页的标识符
        let tabId = sessionStorage.getItem('tabId');

        if (!tabId) {
            // 如果当前标签页没有标识符，生成一个并保存到 sessionStorage
            tabId = generateUniqueId();
            sessionStorage.setItem('tabId', tabId);
        }

        // 存储数据到 localStorage，并添加标识符
        // function saveData(data) {
        //     const key = `data-${tabId}`;
        //     localStorage.setItem(key, JSON.stringify(data));
        // }
        //修改数据
        function saveData(tabIdx, data) {
            if (!tabIdx) {   //key会空，不知道哪里的，先这样吧
                return
            }
            const key = `${tabIdx}`;
            localStorage.setItem(key, JSON.stringify(data));
        }

        // 读取数据
        function loadData(key) {
            // const key = `data-${keyx}`;

            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : null;
        }

        // 删除当前标签页的数据
        function clearData() {
            const key = `data-${tabId}`;
            localStorage.removeItem(key);
        }

        // 在页面关闭前清除数据
        window.addEventListener('beforeunload', function () {
            clearData();
        });




        //////////////////////////////////////////////////////////////位置信息////////////////////////////////////////////////////////////

        function position() {

        }

        function locationInformationStorage(k, box) {
            const rect = box.getBoundingClientRect();
            const screenX = window.screenX || window.screenLeft || 0; // 兼容不同浏览器
            const screenY = window.screenY || window.screenTop || 0;

            const absoluteX = rect.left + screenX;
            const absoluteY = rect.top + screenY;

            return { vpX: absoluteX, vpY: absoluteY, boxX: rect.left, boxY: rect.top }
        }

        //修改local存储位置信息
        function modifyCoordinates(draggableElement) {
            const rect = draggableElement.getBoundingClientRect();

            const screenX = window.screenX || window.screenLeft || 0; // 兼容不同浏览器
            const screenY = window.screenY || window.screenTop || 0;

            const absoluteX = rect.left + screenX;
            const absoluteY = rect.top + screenY;

            const x1 = draggableElement.id + ''
            const key = x1.replace('draggableElement-', '')
            saveData(key, {
                vpX: absoluteX,
                vpY: absoluteY,
                boxX: rect.left,
                boxY: rect.top
            })
        }


        // 初始化数据
        function addCoordinates() {

            const screenX = window.screenX || window.screenLeft || 0; // 兼容不同浏览器
            const screenY = window.screenY || window.screenTop || 0;

            let left = 0
            let top = 100

            const absoluteX = left + screenX;
            const absoluteY = top + screenY;

            // 修改位置参数
            saveData(`data-${tabId}`, {
                vpX: absoluteX,
                vpY: absoluteY,
                boxX: left,
                boxY: top,
            })
        }
        addCoordinates()










        //////////////////////////////////////////////////////////////两个盒子之间的线////////////////////////////////////////////////////////////

        // 更新线的位置
        function updateLine(k, o) {
            const draggableElements = document.querySelectorAll(`.draggableElement`);

            for (let j = 0; j < draggableElements.length; j++) {
                const rect1 = draggableElements[j].getBoundingClientRect();
                const a = locationInformationStorage(k[j], draggableElements[j])


                let num = 0
                for (let i = 0; i < draggableElements.length; i++) {

                    if (draggableElements[j].id.replace('draggableElement-','') === k[i]) {
                        continue
                    }

                    const draggableElement = draggableElements[i];


                    const b = locationInformationStorage(k[i], draggableElement)
                    const line = document.getElementById(`line-${k[j]}-${num}`);


                    const centerX_1 = rect1.left + rect1.width / 2;
                    const centerY_1 = rect1.top + rect1.height / 2;
                    const centerX1 = a.vpX + rect1.width / 2;
                    const centerY1 = a.vpY + rect1.height / 2;


                    const centerX2 = b.vpX + rect1.width / 2;
                    const centerY2 = b.vpY + rect1.width / 2;

                    const distance = Math.sqrt(Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2));
                    const angle = Math.atan2(centerY2 - centerY1, centerX2 - centerX1);

                    line.style.width = distance * 2 + 'px';
                    line.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
                    line.style.left = centerX_1 + 'px';
                    line.style.top = centerY_1 + 'px';
                    num++

                }
                num = 0

            }
        }

        // 监听窗口大小变化，以保持线的正确位置
        window.addEventListener('resize', updateLine);





        //////////////////////////////////////////////////////////////节点处理//////////////////////////////////////////////////////////////

        // 增加节点
        function addNodes(key) {
            // 判断节点应该有几个
            let ixi = 0
            if (key.length > ixi) {
                console.log(key);
                for (let i = 0; i < key.length; i++) {
                    for (let j = 0; j < key.length - 1; j++) {
                        // 增加线的数量
                        const div1 = document.createElement('div')
                        div1.classList.add('line')
                        div1.id = `line-${key[i]}-${j}`
                        document.body.appendChild(div1);
                    }
                }
                for (let i = 0; i < key.length; i++) {
                    //增加盒子的数量
                    const div2 = document.createElement('div')
                    div2.classList.add('draggableElement')
                    div2.id = `draggableElement-${key[i]}`
                    document.body.appendChild(div2);
                }
                ixi = key.length
            } else if (key.length < ixi) {
                deleteNode()
                ixi = 0
            }
        }


        //删除节点
        function deleteNode() {
            const lines = document.querySelectorAll('.line');
            lines.forEach(line => {
                document.body.removeChild(line);
            });
            const draggableElements = document.querySelectorAll('.draggableElement');
            draggableElements.forEach(draggableElement => {
                document.body.removeChild(draggableElement);
            });
        }






        ////////////////////////////////////////////////////////////////管理数据//////////////////////////////////////////////////////////////
        // 这个是定时器
        function criminalProcedure() {
            let localStorageKeys = Object.keys(localStorage);
            // 处理数据
            processingData(localStorageKeys)
            //根据local位置更新坐标
            updateCoordinates()
        }

        //处理数据
        function processingData(k) {


            const draggableElements = document.querySelectorAll('.draggableElement');
            //如何他俩互不相等，说明页面增加了，或者删除，要重新加载方法
            if (draggableElements.length !== k.length) {
                console.log('重新加载方法了');
                //拖动效果重新初始化
                dragEffect()
                //节点初始化
                addNodes(k)

                // addCoordinates()
            }

            //更新线的问题
            const obj = []
            for (let i = 0; i < k.length; i++) {
                const element = k[i];
                //读取数据
                obj.push(loadData(element))
            }
            updateLine(k, obj)
        }

        // 根据local位置更新坐标
        function updateCoordinates() {
            let k = Object.keys(localStorage);
            const draggableElements = document.querySelectorAll(`.draggableElement`);
            for (let i = 0; i < draggableElements.length; i++) {
                const draggableElement = draggableElements[i];

                for (let j = 0; j < k.length; j++) {
                    const key = k[j];
                    
                    if (draggableElements[j].id.replace('draggableElement-','') !== k[i]) {
                        continue
                    }

                    draggableElement.style.left =  loadData(key).vpX - windowCoordinates().winX + 'px';
                    draggableElement.style.top =  loadData(key).vpY - windowCoordinates().winY + 'px';
                }
            }
        }

        // 获取浏览器窗口坐标
        function windowCoordinates() {
            return { winX: window.screenX, winY: window.screenY }
        }






















    </script>
</body>

</html>